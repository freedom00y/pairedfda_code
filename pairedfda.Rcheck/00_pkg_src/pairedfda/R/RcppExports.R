# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' One EM iterate
#' @param oldpara parameter set from the last step
#' @param data postprocessed data
#' @param lambda tuning parameter
#' @return new parameter set
#' @keywords internal
#' [[Rcpp::export]]
NULL

#' @keywords internal 
f <- function(x, n, slogu, su) {
    .Call(`_pairedfda_f`, x, n, slogu, su)
}

#' @keywords internal 
df <- function(x, n, slogu, su) {
    .Call(`_pairedfda_df`, x, n, slogu, su)
}

#' @keywords internal 
newton_md <- function(n, slogu, su) {
    .Call(`_pairedfda_newton_md`, n, slogu, su)
}

#' @importFrom heavy pgamma.deriv
#' @keywords internal 
slash_u <- function(gama, ni, delta) {
    .Call(`_pairedfda_slash_u`, gama, ni, delta)
}

#' Estimations
#' 
#' Use this function to estimate parameters
#' 
#' @param data Processed data. Use predata to preprocess first.
#' @param lambda The penalty patameters, a vector with 4 components showing in the following order, the first mean curve \eqn{(\lambda_\mu)}, the second mean curve \eqn{(\lambda_\nu)}, the first pcs \eqn{(\lambda_f)}, the second pcs \eqn{(\lambda_g)}.
#' @param type Model type. 'n' means normal distribution, 't' means student-t distribution, 's' means slash distribution
#' @param ka Number of pcs for the first reponse variable (Y)
#' @param kb Number of pcs for the second reponse variable (Z)
#' @param tol Tolerance of the EM algorithm. The default one is 1e-4.
#' @param maxiter Maximum iteration time. The default is 100 times.
#' 
#' @return The estimated parameters
#' 
#' @details  We suppose the model is 
#' \deqn{Y_i = B_i \theta_\mu + B_i f \alpha_i + \epsilon_i, Z_i = B_i \theta_\nu + B_i g \beta_i + \xi_i,}
#' where \eqn{(\alpha_i, \beta_i)} and residuals follow normal, t or slash distribution. We denote that 
#' \deqn{(\alpha_i, \beta_i)|u_i \sim N(0,\Sigma_{\alpha\beta}/u_i), \epsilon_i|u_i\sim N(0,\sigma_\epsilon^2/u_i), \xi_i|u_i\sim N(0,\sigma_\xi^2/u_i), u_i\sim H(\gamma).}
#' If \eqn{(\alpha_i, \beta_i)} and residuals follow normal, it means \eqn{H(\gamma)=1} all the time; 
#' if \eqn{(\alpha_i, \beta_i)} and residuals follow t distribution, it means \eqn{H(\gamma)} is the distribution \eqn{\Gamma(\gamma/2,\gamma/2)};
#' if \eqn{(\alpha_i, \beta_i)} and residuals follow slash distribution, it means \eqn{H(\gamma)} is the distribution \eqn{\beta(\gamma,1)},
#' where \eqn{\Sigma_{\alpha\beta} = (D_a & C\\C^T & Db)}.
#' This function returns the estimation of \eqn{\sigma^2_\epsilon,\sigma^2_\xi,\theta_\mu,\theta_\nu,\theta_f,\theta_g,Da,Db,C}, the degree of freedom \eqn{\gamma}.
#' 
#' @examples 
#' rawdata = gen_data(n=100,
#'                    varres=0.01, 
#'                    gama=2, 
#'                    type='t',
#'                    ka=2,
#'                    kb=2)
#' data = predata(nobs_y = rawdata$obs_times,
#'                nobs_z = rawdata$obs_times,
#'                time_y = rawdata$dataset[,2],
#'                time_z = rawdata$dataset[,2],
#'                y = rawdata$dataset[,3],
#'                z = rawdata$dataset[,4],
#'                knots = 10,
#'                order=3)
#' ## without penalty
#' lambda = c(0,0,0,0)
#' pt_nopen = minEM(data, 
#'                  lambda, 
#'                  type='t', 
#'                  ka=2, 
#'                  kb=2, 
#'                  tol = 1e-4, 
#'                  maxiter = 100)
#' ## with penalty
#' lambda_t = simplex(data,Kfold=5,ka=2,kb=2,type='t')
#' pt_pen = minEM(data, 
#'                lambda_t, 
#'                type='t', 
#'                ka=2, 
#'                kb=2, 
#'                tol = 1e-4, 
#'                maxiter = 100)
minEM <- function(data, lambda, type, ka, kb, tol, maxiter = 100L) {
    .Call(`_pairedfda_minEM`, data, lambda, type, ka, kb, tol, maxiter)
}

#' @keywords internal 
mu_t <- function(t) {
    .Call(`_pairedfda_mu_t`, t)
}

#' @keywords internal 
nu_t <- function(t) {
    .Call(`_pairedfda_nu_t`, t)
}

#' @keywords internal 
f_y1 <- function(t) {
    .Call(`_pairedfda_f_y1`, t)
}

#' @keywords internal 
f_y2 <- function(t) {
    .Call(`_pairedfda_f_y2`, t)
}

#' @keywords internal 
f_z1 <- function(t) {
    .Call(`_pairedfda_f_z1`, t)
}

#' @keywords internal 
f_z2 <- function(t) {
    .Call(`_pairedfda_f_z2`, t)
}

#' Generate simulation data
#' 
#' @description Use this function to generate data to get familiar with this package. The simulated data have the same setting as the paper describes. 
#' 
#' @param n number of subjects
#' @param varres variance or conditional variance of residuals
#' @param gama the degree of freedoms for slash and t distribution
#' @param type model type. 'n' means normal, 't' means t distribution, 's' means slash distribution
#' @param ka number of pcs for the first response variable (Y)
#' @param kb number of pcs for the second response variable (Z)
#' 
#' @return simulated data
#' 
#' @examples 
#' rawdata = gen_data(n=100,varres=0.01, gama=2, type='t',ka=2,kb=2)
gen_data <- function(n, varres, gama = 2.0, type = 'n', ka = 2L, kb = 2L) {
    .Call(`_pairedfda_gen_data`, n, varres, gama, type, ka, kb)
}

#' Evaluate the loglikelihood value
#' @param data postprocessed data
#' @param para parameter set
#' @return -2*log-likelihood value
#' @keywords internal
#' @importFrom heavy pgamma.deriv
loglike <- function(data, para, type) {
    .Call(`_pairedfda_loglike`, data, para, type)
}

#' orthogonalize the covariance matrix
#' @param Th theta before orthogonalize
#' @param V covariance matrix before
#' @return orthogonalized theta and covariance matrix
#' @keywords internal 
orth_algo <- function(Th, V) {
    .Call(`_pairedfda_orth_algo`, Th, V)
}

